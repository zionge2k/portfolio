---
title: "Next.js SEO 실전: Metadata부터 소셜 공유까지"
description: "Next.js Metadata API, robots.txt, sitemap.xml 자동 생성, Open Graph와 Twitter Card 설정까지. 검색엔진과 소셜 미디어에 내 사이트를 알리는 법."
date: "2026-02-02"
tags: ["seo", "nextjs", "metadata", "open-graph"]
published: true
---

## 이 글의 위치

[1편](/blog/2026-02-01-seo-fundamentals)에서 SEO의 전체 그림을 잡았다. 이 글에서는 Next.js에 실제로 SEO를 적용한다.

다루는 내용:
- **Metadata API** — 페이지의 title, description 등을 설정
- **robots.txt / sitemap.xml** — 크롤러에게 사이트 구조를 알려줌
- **Open Graph / Twitter Card** — 소셜 미디어 공유 시 미리보기 카드

## Metadata API

Next.js App Router는 `metadata`를 프레임워크 레벨에서 지원한다. HTML의 `<head>`에 들어가는 메타 태그를 직접 쓰지 않아도 된다.

### 정적 Metadata

페이지의 메타데이터가 빌드 시점에 확정되는 경우다.

```tsx
// app/about/page.tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: '소개',
  description: '프론트엔드 개발자 이성의 포트폴리오',
}

export default function AboutPage() {
  return <main>...</main>
}
```

이렇게 하면 Next.js가 자동으로 `<head>`에 넣어준다:

```html
<title>소개</title>
<meta name="description" content="프론트엔드 개발자 이성의 포트폴리오" />
```

### 동적 Metadata — generateMetadata

블로그처럼 slug에 따라 메타데이터가 달라지는 경우다. `generateMetadata` 함수를 사용한다.

```tsx
// app/blog/[slug]/page.tsx
import type { Metadata } from 'next'

type Props = {
  params: Promise<{ slug: string }>
}

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = await params
  const post = getPostBySlug(slug)

  return {
    title: post.frontmatter.title,
    description: post.frontmatter.description,
  }
}

export default async function BlogPost({ params }: Props) {
  const { slug } = await params
  // ...
}
```

핵심: `generateMetadata`는 서버에서 실행된다. DB 조회, 파일 읽기 등 서버 작업이 가능하다.

### Layout에서의 Metadata 상속

Next.js의 metadata는 **레이아웃 계층을 따라 병합**된다.

```tsx
// app/layout.tsx (루트 레이아웃)
export const metadata: Metadata = {
  title: {
    template: '%s | 이성 포트폴리오',  // %s에 자식 페이지의 title이 들어감
    default: '이성 포트폴리오',        // 자식이 title을 안 쓰면 이걸 사용
  },
  description: '프론트엔드 개발자 이성의 포트폴리오',
}
```

```tsx
// app/blog/[slug]/page.tsx
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = await params
  const post = getPostBySlug(slug)

  return {
    title: post.frontmatter.title,  // "SEO 기초 가이드"
  }
}
```

결과:

```html
<!-- 최종 렌더링되는 title -->
<title>SEO 기초 가이드 | 이성 포트폴리오</title>
```

`title.template`의 `%s`에 자식의 title이 들어간다. 이렇게 하면 모든 페이지에 일관된 브랜딩을 적용하면서, 각 페이지가 자기 title만 신경 쓰면 된다.

## robots.txt

1편에서 봤듯이 크롤러는 사이트에 접근할 때 `robots.txt`를 먼저 확인한다. Next.js에서는 두 가지 방법으로 생성할 수 있다.

### 방법 1: 정적 파일

`app/robots.txt` 파일을 직접 만든다.

```txt
User-agent: *
Allow: /
Disallow: /api/

Sitemap: https://example.com/sitemap.xml
```

### 방법 2: robots.ts (동적 생성)

환경에 따라 다르게 생성해야 하면 `robots.ts`를 쓴다.

```ts
// app/robots.ts
import type { MetadataRoute } from 'next'

export default function robots(): MetadataRoute.Robots {
  return {
    rules: {
      userAgent: '*',
      allow: '/',
      disallow: '/api/',
    },
    sitemap: 'https://example.com/sitemap.xml',
  }
}
```

빌드하면 `/robots.txt` 경로에 텍스트 파일이 생성된다.

## sitemap.xml

크롤러에게 "내 사이트에는 이런 페이지들이 있어"라고 알려주는 파일이다. 크롤러가 링크를 따라가는 것보다 훨씬 효율적으로 모든 페이지를 발견할 수 있다.

### sitemap.ts (동적 생성)

블로그처럼 페이지가 계속 추가되는 경우, 동적으로 생성하는 게 좋다.

```ts
// app/sitemap.ts
import type { MetadataRoute } from 'next'
import { getAllPosts } from '@/lib/blog'

export default function sitemap(): MetadataRoute.Sitemap {
  const posts = getAllPosts()

  const blogEntries = posts.map((post) => ({
    url: `https://example.com/blog/${post.slug}`,
    lastModified: new Date(post.frontmatter.date),
    changeFrequency: 'monthly' as const,
    priority: 0.7,
  }))

  return [
    {
      url: 'https://example.com',
      lastModified: new Date(),
      changeFrequency: 'yearly',
      priority: 1,
    },
    {
      url: 'https://example.com/about',
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 0.8,
    },
    ...blogEntries,
  ]
}
```

빌드하면 `/sitemap.xml`에 이런 XML이 생성된다:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://example.com</loc>
    <lastmod>2026-02-02</lastmod>
    <changefreq>yearly</changefreq>
    <priority>1</priority>
  </url>
  <url>
    <loc>https://example.com/blog/seo-fundamentals</loc>
    <lastmod>2026-02-01</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.7</priority>
  </url>
</urlset>
```

### sitemap의 필드 설명

- **url** — 페이지의 절대 URL
- **lastModified** — 마지막 수정일. 크롤러가 재방문 판단에 사용
- **changeFrequency** — 변경 빈도 힌트 (`always`, `hourly`, `daily`, `weekly`, `monthly`, `yearly`, `never`)
- **priority** — 사이트 내 상대적 중요도 (0.0 ~ 1.0). 크롤러 참고용일 뿐, 랭킹에는 영향 없음

## Open Graph

**Open Graph (OG)** 는 Facebook이 만든 프로토콜이다. 웹페이지의 정보를 **소셜 미디어가 이해할 수 있는 형태**로 제공한다.

카카오톡, Slack, Discord에 URL을 붙여넣으면 나오는 미리보기 카드 — 그게 OG 태그를 읽은 결과다.

### OG 태그가 없으면

```
https://example.com/blog/seo-guide
```

그냥 URL 텍스트만 보인다. 아무 정보도 없다.

### OG 태그가 있으면

제목, 설명, 이미지가 카드 형태로 표시된다. 클릭률이 크게 올라간다.

### Next.js에서 설정

Metadata API에 `openGraph` 필드를 추가하면 된다.

```tsx
// app/layout.tsx
export const metadata: Metadata = {
  title: {
    template: '%s | 이성 포트폴리오',
    default: '이성 포트폴리오',
  },
  openGraph: {
    type: 'website',
    locale: 'ko_KR',
    siteName: '이성 포트폴리오',
  },
}
```

```tsx
// app/blog/[slug]/page.tsx
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = await params
  const post = getPostBySlug(slug)

  return {
    title: post.frontmatter.title,
    description: post.frontmatter.description,
    openGraph: {
      title: post.frontmatter.title,
      description: post.frontmatter.description,
      type: 'article',
      publishedTime: post.frontmatter.date,
      url: `https://example.com/blog/${slug}`,
      images: [
        {
          url: `https://example.com/og/${slug}.png`,
          width: 1200,
          height: 630,
          alt: post.frontmatter.title,
        },
      ],
    },
  }
}
```

렌더링 결과:

```html
<meta property="og:title" content="SEO 기초 가이드" />
<meta property="og:description" content="검색엔진 최적화의 기초부터..." />
<meta property="og:type" content="article" />
<meta property="og:image" content="https://example.com/og/seo-guide.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
```

### OG 이미지 권장 사양

- **크기**: 1200 x 630px (1.91:1 비율)
- **파일 크기**: 5MB 이하
- **포맷**: PNG, JPEG

## Twitter Card

Twitter(X)는 OG 태그와 별도로 자체 메타 태그를 사용한다. 하지만 OG 태그가 있으면 Twitter도 fallback으로 읽기 때문에, **OG를 먼저 설정하고 Twitter는 추가 설정만** 하면 된다.

### Next.js에서 설정

```tsx
export const metadata: Metadata = {
  twitter: {
    card: 'summary_large_image',  // 큰 이미지 카드
    creator: '@twitter_handle',
  },
}
```

`card` 타입:
- `summary` — 작은 썸네일 + 제목 + 설명
- `summary_large_image` — 큰 이미지 + 제목 + 설명 (보통 이걸 쓴다)

`title`, `description`, `images`는 `openGraph`에서 설정한 값이 자동으로 사용된다. 중복 설정할 필요 없다.

## 확인 방법

설정을 마쳤으면 제대로 적용되었는지 확인한다.

- **메타 태그 확인**: 브라우저 개발자 도구 → Elements → `<head>` 태그 내부
- **OG 미리보기**: [OpenGraph.xyz](https://www.opengraph.xyz/) — URL을 넣으면 소셜 미디어에서 어떻게 보이는지 확인
- **Twitter 미리보기**: [Twitter Card Validator](https://cards-dev.twitter.com/validator)
- **구조화 데이터**: [Google Rich Results Test](https://search.google.com/test/rich-results)
- **전체 SEO 점검**: 브라우저 개발자 도구 → Lighthouse → SEO 카테고리

## 참고

- `metadata`와 `generateMetadata`를 같은 파일에서 동시에 사용할 수 없다. 둘 중 하나만 선택
- `generateMetadata`에서 `fetch`를 쓰면 Next.js가 자동으로 요청을 deduplicate한다 (같은 URL이면 한 번만 호출)
- OG 이미지를 동적으로 생성하려면 Next.js의 `ImageResponse` (next/og)를 사용할 수 있다
- 다음 글에서 JSON-LD 구조화 데이터와 Core Web Vitals 최적화를 다룬다
