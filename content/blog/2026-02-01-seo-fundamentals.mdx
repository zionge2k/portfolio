---
title: "SEO 기초: 검색엔진은 내 사이트를 어떻게 이해하는가"
description: "검색엔진의 동작 원리(크롤링, 인덱싱, 랭킹)부터 On-Page, Technical, Off-Page SEO까지. Next.js 개발자가 알아야 할 SEO 기초 전체 그림."
date: "2026-02-01"
tags: ["seo", "nextjs", "web"]
published: true
---

## SEO란

**Search Engine Optimization** — 검색엔진에서 내 웹사이트가 더 잘 노출되도록 최적화하는 것이다.

핵심 질문은 하나다:

> 사용자가 특정 키워드를 검색했을 때, 내 페이지가 상위에 나오려면 어떻게 해야 하는가?

이걸 이해하려면 검색엔진이 어떻게 동작하는지부터 알아야 한다.

## 검색엔진의 동작 원리

검색엔진은 3단계로 동작한다: **Crawling → Indexing → Ranking**.

### 1. Crawling (크롤링)

검색엔진의 봇(Googlebot 등)이 웹을 돌아다니며 페이지를 **발견**하는 단계다.

- 봇은 링크를 따라 페이지에서 페이지로 이동한다
- `robots.txt`를 먼저 확인해서 "이 페이지는 크롤링해도 되는가?"를 판단한다
- `sitemap.xml`을 통해 사이트의 전체 페이지 목록을 파악한다

```txt
# robots.txt 예시
User-agent: *
Allow: /
Disallow: /api/
Sitemap: https://example.com/sitemap.xml
```

**크롤러가 발견하지 못하면, 그 페이지는 검색 결과에 절대 나오지 않는다.**

### 2. Indexing (인덱싱)

크롤링한 페이지의 내용을 **분석하고 저장**하는 단계다.

봇이 분석하는 것들:
- `<title>`, `<meta description>` — 페이지의 제목과 설명
- `<h1>` ~ `<h6>` — 콘텐츠의 구조와 계층
- 본문 텍스트 — 페이지의 핵심 내용
- 이미지의 `alt` 속성 — 이미지가 무엇인지
- 링크의 `href`와 anchor text — 페이지 간 관계

분석 결과는 검색엔진의 데이터베이스(인덱스)에 저장된다.

여기서 중요한 점이 하나 있다. **봇은 JavaScript를 완벽하게 실행하지 못할 수 있다.** React SPA로 만든 사이트를 생각해보면:

```html
<!-- 크롤러가 처음 받는 HTML -->
<html>
  <body>
    <div id="root"></div>
    <script src="bundle.js"></script>
  </body>
</html>
```

JS가 실행되기 전에는 빈 페이지다. 크롤러가 JS를 실행하지 않으면 아무 콘텐츠도 인덱싱할 수 없다. 이것이 **SSR이 SEO에 중요한 이유**이고, Next.js를 쓰는 큰 이유 중 하나다.

### 3. Ranking (랭킹)

사용자가 검색했을 때, 인덱스에서 **가장 관련성 높은 페이지를 순서대로 보여주는** 단계다.

Google의 랭킹 요소는 200개 이상이라고 알려져 있지만, 핵심만 보면:

- **콘텐츠 관련성** — 검색어와 페이지 내용이 얼마나 관련 있는가
- **콘텐츠 품질** — 유용하고, 신뢰할 수 있고, 독창적인 콘텐츠인가
- **백링크** — 다른 사이트에서 내 사이트로 링크하는 수와 품질
- **사용자 경험** — 페이지 속도, 모바일 대응, Core Web Vitals
- **기술적 요소** — 올바른 HTML 구조, HTTPS, 크롤링 가능성

## SEO의 세 가지 영역

### On-Page SEO (페이지 내부)

개발자가 직접 제어할 수 있는 영역이다.

**Title 태그** — 검색 결과에 보이는 페이지 제목이다. 50~60자가 적당하다.

```html
<title>SEO 기초 가이드 | 내 블로그</title>
```

**Meta Description** — 검색 결과의 설명문이다. 150~160자가 적당하다.

```html
<meta name="description" content="검색엔진 최적화의 기초부터..." />
```

**Heading 구조** — `<h1>`은 페이지당 1개. `<h2>` ~ `<h6>`으로 계층을 만든다.

```html
<h1>SEO 기초 가이드</h1>          <!-- 페이지 주제 -->
  <h2>검색엔진의 동작 원리</h2>    <!-- 큰 섹션 -->
    <h3>크롤링</h3>                <!-- 세부 항목 -->
    <h3>인덱싱</h3>
```

**시맨틱 HTML** — `<div>` 대신 의미 있는 태그를 쓴다.

```html
<!-- Bad -->
<div class="nav">...</div>
<div class="main">...</div>
<div class="footer">...</div>

<!-- Good -->
<nav>...</nav>
<main>...</main>
<footer>...</footer>
```

크롤러는 시맨틱 태그를 통해 페이지의 구조를 더 정확하게 파악한다.

**이미지 최적화** — `alt` 속성은 필수다. 크롤러는 이미지를 "볼" 수 없기 때문이다.

```html
<!-- Bad -->
<img src="photo.jpg" />

<!-- Good -->
<img src="photo.jpg" alt="서울 남산타워 야경 사진" />
```

### Technical SEO (기술적)

크롤러가 사이트를 잘 이해할 수 있도록 하는 기술적 설정이다.

- **robots.txt** — 크롤러의 접근을 제어한다
- **sitemap.xml** — 사이트의 전체 페이지 목록을 제공한다
- **canonical URL** — 중복 콘텐츠를 방지한다

```html
<!-- 같은 페이지에 여러 URL로 접근 가능할 때 -->
<!-- https://example.com/blog/seo -->
<!-- https://example.com/blog/seo?ref=twitter -->
<link rel="canonical" href="https://example.com/blog/seo" />
```

- **구조화된 데이터 (JSON-LD)** — 검색엔진에 페이지의 의미를 명시적으로 전달한다

```html
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SEO 기초 가이드",
  "author": { "@type": "Person", "name": "이성" }
}
</script>
```

- **Core Web Vitals** — Google이 측정하는 사용자 경험 지표

| 지표 | 측정 대상 | 기준 |
|------|----------|------|
| LCP (Largest Contentful Paint) | 가장 큰 콘텐츠가 보이기까지의 시간 | 2.5초 이내 |
| INP (Interaction to Next Paint) | 사용자 인터랙션 응답 속도 | 200ms 이내 |
| CLS (Cumulative Layout Shift) | 레이아웃이 얼마나 밀리는가 | 0.1 이하 |

- **HTTPS** — 보안 연결은 랭킹 요소다
- **모바일 대응** — Google은 모바일 버전을 기준으로 인덱싱한다 (Mobile-First Indexing)

### Off-Page SEO (외부)

사이트 외부에서 일어나는 활동이다. 개발보다는 마케팅 영역에 가깝다.

- **백링크** — 다른 사이트에서 내 사이트로의 링크. 양보다 품질이 중요하다
- **소셜 시그널** — SNS 공유, 언급
- **브랜드 인지도** — 브랜드명 직접 검색량

개발자가 집중해야 할 것은 On-Page SEO와 Technical SEO다. Off-Page는 좋은 콘텐츠를 만들면 자연스럽게 따라온다.

## Next.js와 SEO

Next.js가 SEO에 유리한 이유를 정리하면:

**SPA(React)의 문제:**
```
1. 브라우저가 빈 HTML을 받는다 (<div id="root"></div>)
2. JS를 다운로드하고 실행해야 콘텐츠가 렌더링된다
3. 크롤러가 JS를 실행하지 못하면 빈 페이지로 인식한다
```

**Next.js의 해결:**
```
1. 서버에서 HTML을 완성해서 보낸다 (SSR/SSG)
2. 크롤러가 JS 없이도 완전한 콘텐츠를 읽을 수 있다
3. App Router의 Server Components는 기본이 서버 렌더링이다
```

추가로 Next.js는 SEO에 필요한 것들을 프레임워크 레벨에서 지원한다:

- `Metadata API` — title, description, Open Graph 등을 쉽게 설정
- `sitemap.ts` — sitemap.xml 자동 생성
- `robots.ts` — robots.txt 자동 생성
- `next/image` — 이미지 최적화 (WebP 변환, lazy loading)
- `generateStaticParams` — 정적 페이지 사전 생성

## 참고

- 이 글은 SEO의 전체 그림을 잡기 위한 기초편이다
- 다음 글에서 Next.js에 실제로 SEO를 적용하는 방법을 다룬다
- Google의 공식 SEO 가이드: [Google Search Central](https://developers.google.com/search/docs)
- Core Web Vitals 측정: [PageSpeed Insights](https://pagespeed.web.dev/)
